import 'dotenv/config';freshing-adaptation-rbe-serveurs.up.railway.app
import express from 'express';cret
import cors from 'cors';import { PrismaClient } from '@prisma/client';import multer from 'multer';import path from 'path';import fs from 'fs';import QRCode from 'qrcode';import { Helmet } from "react-helmet-async";import { Box, Container, Heading, Text, VStack, Button, Badge, HStack, Spinner } from "@chakra-ui/react";import { Link as RouterLink } from "react-router-dom";import { useEffect, useState } from "react";import jwt from 'jsonwebtoken';import { USERS } from './auth/users.js';const app = express();const PORT = process.env.PORT || 4000;// Configapp.use(express.json());app.use(cors({  origin: (origin, cb) => {    const allowed = [      'http://localhost:5173',      'http://localhost:4173',      'http://localhost:3000',      'http://localhost:5174',      'https://www.association-rbe.fr',      'https://association-rbe.fr',      'https://retrobus-interne.fr',      'https://www.retrobus-interne.fr',      'https://refreshing-adaptation-rbe-serveurs.up.railway.app'    ];    if (!origin || allowed.includes(origin)) return cb(null, true);    return cb(new Error('Origin not allowed'));  },  credentials: true}));let prisma;try {  prisma = new PrismaClient();  console.log('✅ Prisma Client initialized');} catch (error) {  console.error('❌ Failed to initialize Prisma Client:', error);  prisma = null;}// Helper functions for JSON handlingconst parseJsonField = (field) => {  if (!field) return null;  if (typeof field === 'string') {    try {      return JSON.parse(field);    } catch {      return null;    }  }  return field;};const stringifyJsonField = (field) => {  if (!field) return null;  if (typeof field === 'string') return field;  try {    return JSON.stringify(field);  } catch {    return null;  }};const API_BASE = process.env.PUBLIC_API_BASE || ''; // ou `https://${process.env.RAILWAY_STATIC_URL}` si fournifunction absolutize(path) {  if (!path) return path;  if (path.startsWith('http://') || path.startsWith('https://')) return path;  if (!API_BASE) return path; // fallback relatif  return `${API_BASE}${path}`;}// Transform vehicle data for API responsesconst transformVehicle = (vehicle) => {  if (!vehicle) return null;  let caract = [];  try { caract = vehicle.caracteristiques ? JSON.parse(vehicle.caracteristiques) : []; } catch {}  const gallery = parseJsonField(vehicle.gallery) || [];  return {    id: vehicle.id,    parc: vehicle.parc,    type: vehicle.type,    modele: vehicle.modele,    marque: vehicle.marque,    subtitle: vehicle.subtitle,    immat: vehicle.immat,    etat: vehicle.etat,    miseEnCirculation: vehicle.miseEnCirculation,    energie: vehicle.energie,    description: vehicle.description,    history: vehicle.history, // conserver la clé exacte attendue côté externe    backgroundImage: absolutize(vehicle.backgroundImage),    backgroundPosition: vehicle.backgroundPosition,    gallery: gallery.map(absolutize),    caracteristiques: caract  };};const transformEvent = (evt) => {  if (!evt) return null;  return {    id: evt.id,    title: evt.title,    date: evt.date,    time: evt.time,    location: evt.location,    description: evt.description,    helloAssoUrl: evt.helloAssoUrl,    adultPrice: evt.adultPrice,    childPrice: evt.childPrice,    // champs futurs (layout, extras) non exposés pour ne pas casser l’externe tant qu’il ne les consomme pas  };};// ---------- Utils ----------const ensureDB = (res) => {  if (!prisma) {    console.error('Prisma non initialisé');    res.status(500).json({ error: 'Database not initialized' });    return false;  }  return true;};const AUTH_SECRET = process.env.AUTH_SECRET || 'dev_insecure_secret';const TOKEN_TTL = process.env.TOKEN_TTL || '12h';function issueToken(payload) {  return jwt.sign(payload, AUTH_SECRET, { expiresIn: TOKEN_TTL });}function verifyToken(token) {  return jwt.verify(token, AUTH_SECRET);}function requireAuth(req, res, next) {  const auth = req.headers.authorization;  if (!auth || !auth.startsWith('Bearer ')) {    return res.status(401).json({ error: 'Missing token' });  }  const token = auth.slice(7);  try {    const decoded = verifyToken(token);    req.user = decoded;    next();  } catch (e) {    return res.status(401).json({ error: 'Invalid or expired token' });  }}// ---------- File upload setup ----------const galleryStorage = multer.diskStorage({  destination: (req, file, cb) => {    const dir = path.join(process.cwd(), 'uploads', 'vehicles');    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });    cb(null, dir);  },  filename: (req, file, cb) => cb(null, `${Date.now()}-${file.originalname}`)});const uploadGallery = multer({ storage: galleryStorage });// ---------- Vehicle CRUD ----------app.get('/vehicles', requireAuth, async (_req, res) => {  if (!ensureDB(res)) return;  try {    const vehicles = await prisma.vehicle.findMany({      orderBy: { parc: 'asc' }    });    const transformedVehicles = vehicles.map(transformVehicle);    res.json(transformedVehicles);  } catch (e) {    console.error(e);    res.status(500).json({ error: 'Failed to fetch vehicles' });  }});app.get('/vehicles/:parc', requireAuth, async (req, res) => {  if (!ensureDB(res)) return;  try {    const { parc } = req.params;    const vehicle = await prisma.vehicle.findUnique({ where: { parc } });    if (!vehicle) return res.status(404).json({ error: 'Véhicule introuvable' });    res.json(transformVehicle(vehicle));  } catch (e) {    console.error(e);    res.status(500).json({ error: 'Failed to fetch vehicle' });  }});app.post('/vehicles', requireAuth, async (req, res) => {  if (!ensureDB(res)) return;  try {    const {      parc, etat = 'disponible', immat, energie, miseEnCirculation,      modele = '', type = 'Bus', marque, subtitle, description, history,      caracteristiques, gallery    } = req.body || {};    if (!parc) return res.status(400).json({ error: 'Le champ "parc" est requis' });    const data = {      parc, etat, modele, type,      immat: immat || null,      energie: energie || null,      marque: marque || null,      subtitle: subtitle || null,      description: description || null,      history: history || null,      caracteristiques: stringifyJsonField(caracteristiques),      gallery: stringifyJsonField(gallery),      miseEnCirculation: miseEnCirculation ? new Date(miseEnCirculation) : null    };    const created = await prisma.vehicle.create({ data });    res.json(transformVehicle(created));  } catch (e) {    console.error(e);    res.status(500).json({ error: 'Create failed' });  }});app.put('/vehicles/:parc', requireAuth, async (req, res) => {  if (!ensureDB(res)) return;  try {    const { parc } = req.params;    const body = { ...req.body };    const existing = await prisma.vehicle.findUnique({ where: { parc } });    if (!existing) return res.status(404).json({ error: 'Véhicule introuvable' });    // Caractéristiques existantes    let caract = {};    if (existing.caracteristiques) {      try { caract = JSON.parse(existing.caracteristiques); } catch {}    }    const caractKeys = [      'fleetNumbers','constructeur','miseEnCirculationTexte',      'longueur','placesAssises','placesDebout','ufr',      'preservePar','normeEuro','moteur','boiteVitesses',      'nombrePortes','livree','girouette','climatisation'    ];    const directMap = {      modele: 'modele',      marque: 'marque',      subtitle: 'subtitle',      immat: 'immat',      etat: 'etat',      type: 'type',      energie: 'energie',      description: 'description',      histoire: 'history'    };    const dataUpdate = {};    Object.entries(directMap).forEach(([frontKey, dbKey]) => {      if (body[frontKey] !== undefined) {        dataUpdate[dbKey] = body[frontKey] === '' ? null : body[frontKey];        delete body[frontKey];      }    });    if (body.miseEnCirculation !== undefined) {      dataUpdate.miseEnCirculation = body.miseEnCirculation        ? new Date(body.miseEnCirculation)        : null;      delete body.miseEnCirculation;    }    caractKeys.forEach(k => {      if (body[k] !== undefined) {        if (body[k] === '' || body[k] === null) {          delete caract[k];        } else {          caract[k] = body[k];        }        delete body[k];      }    });    if (Array.isArray(body.caracteristiques)) {      dataUpdate.caracteristiques = JSON.stringify(body.caracteristiques);      delete body.caracteristiques;    }    if (body.backgroundImage !== undefined) {      dataUpdate.backgroundImage = body.backgroundImage; // null pour effacer OK      delete body.backgroundImage;    }    if (body.backgroundPosition !== undefined) {      dataUpdate.backgroundPosition = body.backgroundPosition;      delete body.backgroundPosition;    }    dataUpdate.caracteristiques = Object.keys(caract).length      ? JSON.stringify(caract)      : null;    const updated = await prisma.vehicle.update({      where: { parc },      data: dataUpdate    });    res.json(transformVehicle(updated));  } catch (e) {    console.error(e);    res.status(500).json({ error: 'Update failed' });  }});app.delete('/vehicles/:parc', requireAuth, async (req, res) => {  if (!ensureDB(res)) return;  try {    const { parc } = req.params;    await prisma.vehicle.delete({ where: { parc } });    res.json({ success: true });  } catch (e) {    console.error(e);    res.status(500).json({ error: 'Delete failed' });  }});// ---------- Galerie upload ----------app.use('/media/vehicles', express.static(path.join(process.cwd(), 'uploads', 'vehicles')));app.post('/vehicles/:parc/gallery', requireAuth, uploadGallery.array('images', 10), async (req, res) => {  if (!ensureDB(res)) return;  try {    const { parc } = req.params;    const v = await prisma.vehicle.findUnique({ where: { parc } });    if (!v) return res.status(404).json({ error: 'Véhicule introuvable' });    const existingGallery = parseJsonField(v.gallery);    const existing = Array.isArray(existingGallery) ? existingGallery : [];    const added = (req.files || []).map(f => `/media/vehicles/${f.filename}`);    const gallery = existing.concat(added);    const updated = await prisma.vehicle.update({      where: { parc },      data: { gallery: stringifyJsonField(gallery) }    });    res.json({ gallery: parseJsonField(updated.gallery) });  } catch (e) {    console.error(e);    res.status(500).json({ error: 'Upload gallery failed' });  }});app.post('/vehicles/:parc/background', requireAuth, uploadGallery.single('image'), async (req, res) => {  if (!ensureDB(res)) return;  try {    const { parc } = req.params;    if (!req.file) return res.status(400).json({ error: 'Fichier manquant' });    const v = await prisma.vehicle.findUnique({ where: { parc } });    if (!v) return res.status(404).json({ error: 'Véhicule introuvable' });    const updated = await prisma.vehicle.update({      where: { parc },      data: { backgroundImage: `/media/vehicles/${req.file.filename}` }    });    res.json({ backgroundImage: updated.backgroundImage });  } catch (e) {    console.error(e);    res.status(500).json({ error: 'Upload background failed' });  }});// Suppression d’une image de galerie (optionnel)app.delete('/vehicles/:parc/gallery', requireAuth, async (req, res) => {  if (!ensureDB(res)) return;  try {    const { parc } = req.params;    const { image } = req.body || {};    if (!image) return res.status(400).json({ error: 'image manquante' });    const v = await prisma.vehicle.findUnique({ where: { parc } });    if (!v) return res.status(404).json({ error: 'Véhicule introuvable' });    let galleryArr = [];    try { galleryArr = JSON.parse(v.gallery || '[]'); } catch {}    const filtered = galleryArr.filter(g => g !== image);    await prisma.vehicle.update({      where: { parc },      data: { gallery: JSON.stringify(filtered) }    });    res.json({ gallery: filtered });  } catch (e) {    console.error(e);    res.status(500).json({ error: 'Delete gallery image failed' });  }});// ---------- Endpoints publics (lecture seule) ----------app.get('/public/vehicles', async (_req, res) => {  if (!ensureDB(res)) return;  try {    const vehicles = await prisma.vehicle.findMany({      select: {        parc: true, type: true, modele: true, marque: true, subtitle: true,        immat: true, etat: true, miseEnCirculation: true, energie: true,        description: true, history: true,        caracteristiques: true, gallery: true,        backgroundImage: true, backgroundPosition: true      }    });    const transformedVehicles = vehicles.map(transformVehicle);    res.json(transformedVehicles);  } catch (e) {    console.error(e);    res.status(500).json({ error: 'Failed to fetch public vehicles' });  }});app.get('/public/vehicles/:parc', async (req, res) => {  if (!ensureDB(res)) return;  try {    const { parc } = req.params;    const vehicle = await prisma.vehicle.findUnique({      where: { parc },      select: {        parc: true, type: true, modele: true, marque: true, subtitle: true,        immat: true, etat: true, miseEnCirculation: true, energie: true,        description: true, history: true,        caracteristiques: true, gallery: true,        backgroundImage: true, backgroundPosition: true      }    });    if (!vehicle) return res.status(404).json({ error: 'Véhicule introuvable' });    res.json(transformVehicle(vehicle));  } catch (e) {    console.error(e);    res.status(500).json({ error: 'Failed to fetch public vehicle' });  }});// ---------- QR Code ----------app.get('/vehicles/:parc/qr', requireAuth, async (req, res) => {  try {    const { parc } = req.params;    const url = `http://localhost:5173/vehicule/${parc}`;    const qr = await QRCode.toDataURL(url);    res.json({ qrCode: qr, url });  } catch (e) {    console.error(e);    res.status(500).json({ error: 'QR generation failed' });  }});// ---------- Usage tracking ----------app.get('/vehicles/:parc/usages', requireAuth, async (req, res) => {  if (!ensureDB(res)) return;  try {    const { parc } = req.params;    const usages = await prisma.usage.findMany({      where: { parc },      orderBy: { startedAt: 'desc' }    });    res.json(usages);  } catch (e) {    console.error(e);    res.status(500).json({ error: 'Failed to fetch usages' });  }});app.post('/vehicles/:parc/usages', requireAuth, async (req, res) => {  if (!ensureDB(res)) return;  try {    const { parc } = req.params;    const { startedAt, endedAt, conducteur, participants, note, relatedTo } = req.body || {};    if (!startedAt) return res.status(400).json({ error: 'startedAt requis' });    const data = {      parc,      startedAt: new Date(startedAt),      endedAt: endedAt ? new Date(endedAt) : null,      conducteur: conducteur || null,      participants: participants || null,      note: note || null,      relatedTo: relatedTo || null    };    const created = await prisma.usage.create({ data });    res.json(created);  } catch (e) {    console.error(e);    res.status(500).json({ error: 'Usage creation failed' });  }});app.put('/usages/:id', requireAuth, async (req, res) => {  if (!ensureDB(res)) return;  try {    const { id } = req.params;    const { startedAt, endedAt, conducteur, participants, note, relatedTo } = req.body || {};    const data = {};    if (startedAt !== undefined) data.startedAt = new Date(startedAt);    if (endedAt !== undefined) data.endedAt = endedAt ? new Date(endedAt) : null;    if (conducteur !== undefined) data.conducteur = conducteur || null;    if (participants !== undefined) data.participants = participants || null;    if (note !== undefined) data.note = note || null;    if (relatedTo !== undefined) data.relatedTo = relatedTo || null;    const updated = await prisma.usage.update({      where: { id: parseInt(id) },      data    });    res.json(updated);  } catch (e) {    console.error(e);    res.status(500).json({ error: 'Usage update failed' });  }});app.delete('/usages/:id', requireAuth, async (req, res) => {  if (!ensureDB(res)) return;  try {    const { id } = req.params;    await prisma.usage.delete({ where: { id: parseInt(id) } });    res.json({ success: true });  } catch (e) {    console.error(e);    res.status(500).json({ error: 'Usage deletion failed' });  }});// ---------- Maintenance reports ----------app.get('/vehicles/:parc/reports', requireAuth, async (req, res) => {  if (!ensureDB(res)) return;  try {    const { parc } = req.params;    const reports = await prisma.report.findMany({      where: { parc },      orderBy: { createdAt: 'desc' }    });    res.json(reports);  } catch (e) {    console.error(e);    res.status(500).json({ error: 'Failed to fetch reports' });  }});app.post('/vehicles/:parc/reports', requireAuth, async (req, res) => {  if (!ensureDB(res)) return;  try {    const { parc } = req.params;    const { description, usageId, filesMeta } = req.body || {};    const data = {      parc,      description: description || null,      usageId: usageId || null,      filesMeta: filesMeta || null    };    const created = await prisma.report.create({ data });    res.json(created);  } catch (e) {    console.error(e);    res.status(500).json({ error: 'Report creation failed' });  }});app.put('/reports/:id', requireAuth, async (req, res) => {  if (!ensureDB(res)) return;  try {    const { id } = req.params;    const { description, usageId, filesMeta } = req.body || {};    const data = {};    if (description !== undefined) data.description = description || null;    if (usageId !== undefined) data.usageId = usageId || null;    if (filesMeta !== undefined) data.filesMeta = filesMeta || null;    const updated = await prisma.report.update({      where: { id: parseInt(id) },      data    });    res.json(updated);  } catch (e) {    console.error(e);    res.status(500).json({ error: 'Report update failed' });  }});app.delete('/reports/:id', requireAuth, async (req, res) => {  if (!ensureDB(res)) return;  try {    const { id } = req.params;    await prisma.report.delete({ where: { id: parseInt(id) } });    res.json({ success: true });  } catch (e) {    console.error(e);    res.status(500).json({ error: 'Report deletion failed' });  }});// ---------- Flash messages ----------app.get('/flashes/all', async (_req, res) => {  if (!ensureDB(res)) return;  try {    const flashes = await prisma.flash.findMany({      where: { active: true },      orderBy: { createdAt: 'desc' }    });    res.json(flashes);  } catch (e) {    console.error(e);    res.status(500).json({ error: 'Failed to fetch flashes' });  }});// ---------- Auth ----------// Utilisateurs (remplacer ensuite par base ou env)const USERS = {  "admin.rbe": {    password: "CHANGER_MOI_2025",    prenom: "Admin",    nom: "RBE",    roles: ["ADMIN"]  },  // Ajouter ici les comptes que tu me fourniras};const AUTH_SECRET = process.env.AUTH_SECRET || 'dev_insecure_secret';const TOKEN_TTL = process.env.TOKEN_TTL || '12h';function issueToken(payload) {  return jwt.sign(payload, AUTH_SECRET, { expiresIn: TOKEN_TTL });}function verifyToken(token) {  return jwt.verify(token, AUTH_SECRET);}function requireAuth(req, res, next) {  const auth = req.headers.authorization;  if (!auth || !auth.startsWith('Bearer ')) {    return res.status(401).json({ error: 'Missing token' });  }  const token = auth.slice(7);  try {    const decoded = verifyToken(token);    req.user = decoded;    next();  } catch (e) {    return res.status(401).json({ error: 'Invalid or expired token' });  }}app.post('/auth/login', (req, res) => {  const { username, password } = req.body || {};  if (!username || !password) {    return res.status(400).json({ error: 'username et password requis' });  }  const u = USERS[String(username).toLowerCase()];  if (!u || u.password !== password) {    return res.status(401).json({ error: 'Identifiants invalides' });  }  const token = issueToken({    sub: username.toLowerCase(),    prenom: u.prenom,    nom: u.nom,    roles: u.roles  });  res.json({    token,    user: {      username: username.toLowerCase(),      prenom: u.prenom,      nom: u.nom,      roles: u.roles    }  });});// ---------- Server start ----------app.listen(PORT, () => {  console.log(`🚀 API Server running on http://localhost:${PORT}`);});export default app;export default function Events() {  const [events, setEvents] = useState(null);  const [error, setError] = useState(null);  useEffect(() => {    const load = async () => {      try {        const base = import.meta.env.VITE_API_URL;        if (!base) throw new Error("API non configurée");        const res = await fetch(`${base}/public/events`);        if (!res.ok) throw new Error("Fetch événements échoué");        const data = await res.json();        // Adapter format date => composant actuel attend AAAA-MM-JJ (on garde tel quel,        // l’API renvoie ISO donc on slice)        const normalized = data.map(e => ({          ...e,          date: (typeof e.date === 'string') ? e.date.substring(0,10) : e.date        }));        setEvents(normalized);      } catch (e) {        console.warn("Fallback événements (raison:", e.message, ")");        setError(e.message);        setEvents(fallbackEvents);      }    };    load();  }, []);  return (    <>      <Helmet>        <title>Événements - Association RétroBus Essonne</title>        <meta name="description" content="Découvrez les prochains événements, sorties et expositions de l'association RétroBus Essonne." />      </Helmet>      <Container maxW="container.lg" py={10}>        <VStack spacing={4} mb={12} textAlign="center">          <Heading as="h1" size="2xl">            Nos Événements          </Heading>          <Text fontSize="lg" color="gray.600">            L'agenda de nos prochaines sorties et manifestations.          </Text>        </VStack>        {events === null ? (          <VStack py={16}><Spinner size="xl" /></VStack>        ) : events.length === 0 ? (          <Box p={8} textAlign="center" bg="gray.50" borderRadius="lg">            <Text fontSize="lg" color="gray.600">              Aucun événement programmé pour le moment.            </Text>            <Text fontSize="md" color="gray.500" mt={2}>              Revenez bientôt pour découvrir nos prochaines sorties !            </Text>          </Box>        ) : (          <VStack spacing={10} align="stretch">            {events.map(event => (              <Box key={event.id} p={8} bg="orange.50" borderRadius="lg" boxShadow="md">                <Heading as="h2" size="lg" color="orange.700" mb={2}>                  {event.title}                </Heading>                <HStack spacing={4} mb={2}>                  <Badge colorScheme="orange">{event.date}</Badge>                  {event.time && <Badge colorScheme="blue">{event.time}</Badge>}                </HStack>                {event.location && (                  <Text fontSize="md" color="gray.700" mb={2}>                    📍 {event.location}                  </Text>                )}                {event.description && (                  <Text fontSize="sm" color="gray.600" mb={4}>                    {event.description}                  </Text>                )}                <HStack spacing={8} mb={4}>                  {event.adultPrice !== undefined && event.adultPrice !== null && (                    <Text fontWeight="bold" color="green.700">                      Adulte : {event.adultPrice}€                    </Text>                  )}                  {event.childPrice !== undefined && event.childPrice !== null && (                    <Text fontWeight="bold" color="green.700">                      Enfant (-12 ans) : {event.childPrice}€                    </Text>                  )}                </HStack>                <Button                  as={RouterLink}                  to={`/evenement/${event.id}/inscription?title=${encodeURIComponent(event.title)}&date=${event.date}&time=${event.time || ''}&location=${encodeURIComponent(event.location || '')}&adultPrice=${event.adultPrice ?? ''}&childPrice=${event.childPrice ?? ''}`}                  colorScheme="orange"                  size="lg"                >                  S'inscrire                </Button>              </Box>            ))}          </VStack>        )}      </Container>    </>  );}// Fallback local (garde la mise en forme si API KO)const fallbackEvents = [  {    id: "halloween2025",    title: "RétroWouh ! Halloween",    date: "2025-10-31",    time: "20:00",    location: "Salle des Fêtes de Villebon",    adultPrice: 15,    childPrice: 8,    description: "Soirée spéciale Halloween avec animations, musique et surprises !",  },];// const requireCreator = (req, res, next) => {//   const authHeader = req.headers.authorization;//   if (!authHeader || authHeader !== 'Bearer creator123') {//     return res.status(401).json({ error: 'Unauthorized' });//   }//   next();// };